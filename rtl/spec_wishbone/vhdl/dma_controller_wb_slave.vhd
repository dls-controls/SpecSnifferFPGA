---------------------------------------------------------------------------------------
-- Title          : Wishbone slave core for GN4124 core DMA controller 
---------------------------------------------------------------------------------------
-- File           : rtl/spec_wishbone/vhdl/dma_controller_wb_slave.vhd
-- Author         : auto-generated by wbgen2 from rtl/spec_wishbone/wb_gen/dma_controller_wb_slave.wb
-- Created        : Tue Nov 11 18:30:13 2014
-- Standard       : VHDL'87
---------------------------------------------------------------------------------------
-- THIS FILE WAS GENERATED BY wbgen2 FROM SOURCE FILE rtl/spec_wishbone/wb_gen/dma_controller_wb_slave.wb
-- DO NOT HAND-EDIT UNLESS IT'S ABSOLUTELY NECESSARY!
---------------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity dma_controller_wb_slave is
  port (
    rst_n_i                                  : in     std_logic;
    clk_sys_i                                : in     std_logic;
    wb_adr_i                                 : in     std_logic_vector(5 downto 0);
    wb_dat_i                                 : in     std_logic_vector(31 downto 0);
    wb_dat_o                                 : out    std_logic_vector(31 downto 0);
    wb_cyc_i                                 : in     std_logic;
    wb_sel_i                                 : in     std_logic_vector(3 downto 0);
    wb_stb_i                                 : in     std_logic;
    wb_we_i                                  : in     std_logic;
    wb_ack_o                                 : out    std_logic;
    wb_stall_o                               : out    std_logic;
    clk_i                                    : in     std_logic;
    fai_clk_i                                : in     std_logic;
-- Ports for asynchronous (clock: clk_i) std_logic_vector field: 'Device Control and Status Register' in reg: 'dcsr'
    dma_dcsr_o                               : out    std_logic_vector(31 downto 0);
    dma_dcsr_i                               : in     std_logic_vector(31 downto 0);
    dma_dcsr_load_o                          : out    std_logic;
-- Ports for asynchronous (clock: clk_i) std_logic_vector field: 'Device DMA Control Status Register' in reg: 'ddmacr'
    dma_ddmacsr_o                            : out    std_logic_vector(31 downto 0);
    dma_ddmacsr_i                            : in     std_logic_vector(31 downto 0);
    dma_ddmacsr_load_o                       : out    std_logic;
-- Ports for asynchronous (clock: clk_i) std_logic_vector field: 'Write DMA Host Lower Address' in reg: 'wdmatlpa'
    dma_wdmatlpa_o                           : out    std_logic_vector(31 downto 0);
    dma_wdmatlpa_i                           : in     std_logic_vector(31 downto 0);
    dma_wdmatlpa_load_o                      : out    std_logic;
-- Ports for asynchronous (clock: clk_i) std_logic_vector field: 'Write DMA TLP Size' in reg: 'wdmatlps'
    dma_wdmatlps_o                           : out    std_logic_vector(31 downto 0);
    dma_wdmatlps_i                           : in     std_logic_vector(31 downto 0);
    dma_wdmatlps_load_o                      : out    std_logic;
-- Ports for asynchronous (clock: clk_i) std_logic_vector field: 'write DMA TLP count' in reg: 'wdmatlpc'
    dma_wdmatlpc_o                           : out    std_logic_vector(31 downto 0);
    dma_wdmatlpc_i                           : in     std_logic_vector(31 downto 0);
    dma_wdmatlpc_load_o                      : out    std_logic;
-- Ports for asynchronous (clock: clk_i) std_logic_vector field: 'write DMA pattern' in reg: 'wdmatlpp'
    dma_wdmatlpp_o                           : out    std_logic_vector(31 downto 0);
    dma_wdmatlpp_i                           : in     std_logic_vector(31 downto 0);
    dma_wdmatlpp_load_o                      : out    std_logic;
-- Port for std_logic_vector field: 'read DMA expected pattern' in reg: 'rdmatlpp'
    dma_rdmatlpp_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'read DMA TLP address' in reg: 'rdmatlpa'
    dma_rdmatlpa_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'read DMA TLP size' in reg: 'rdmatlps'
    dma_rdmatlps_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'read DMA TLP count' in reg: 'rdmatlpc'
    dma_rdmatlpc_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'write DMA performace' in reg: 'wdmaperf'
    dma_wdmaperf_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'read DMA performace' in reg: 'rdmaperf'
    dma_rdmaperf_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'read DMA status' in reg: 'rdmastat'
    dma_rdmastat_o                           : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Number of Read Completion' in reg: 'nrdcomp'
    dma_nrdcomp_o                            : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Read Completion Data Size' in reg: 'rcompdsizw'
    dma_rcompdsizw_o                         : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Device Link Width Status' in reg: 'dlwstat'
    dma_dlwstat_o                            : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Device Link Transaction Size Status' in reg: 'dltrsstat'
    dma_dltrsstat_o                          : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Device Miscellaneous Control' in reg: 'dmisccont'
    dma_dmisccont_o                          : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'CC FAI interrupt clear register' in reg: 'ccfaiirqclr'
    dma_ccfaiirqclr_o                        : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 0' in reg: 'na0'
    dma_na0_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 1' in reg: 'na1'
    dma_na1_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 2' in reg: 'na2'
    dma_na2_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 3' in reg: 'na3'
    dma_na3_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 4' in reg: 'na4'
    dma_na4_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 5' in reg: 'na5'
    dma_na5_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 6' in reg: 'na6'
    dma_na6_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 7' in reg: 'na7'
    dma_na7_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 8' in reg: 'na8'
    dma_na8_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 9' in reg: 'na9'
    dma_na9_o                                : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 10' in reg: 'na10'
    dma_na10_o                               : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 11' in reg: 'na11'
    dma_na11_o                               : out    std_logic_vector(31 downto 0);
-- Port for std_logic_vector field: 'Not Used 12' in reg: 'na12'
    dma_na12_o                               : out    std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller FAI Value' in reg: 'ccfaicfgval'
    dma_ccfaicfgval_o                        : out    std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: clk_i) std_logic_vector field: 'Write DMA Status Register' in reg: 'wdmastatus'
    dma_wdmastatus_i                         : in     std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller Link Status' in reg: 'linkstatus'
    dma_linkstatus_i                         : in     std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller Frame Error Status' in reg: 'frameerrcnt'
    dma_frameerrcnt_i                        : in     std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller Soft Error Status' in reg: 'softerrcnt'
    dma_softerrcnt_i                         : in     std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller Hard Error Status' in reg: 'harderrcnt'
    dma_harderrcnt_i                         : in     std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller NodeID' in reg: 'nodeid'
    dma_nodeid_o                             : out    std_logic_vector(31 downto 0);
-- Port for asynchronous (clock: fai_clk_i) std_logic_vector field: 'Communication Controller Timeframe Length' in reg: 'timeframelen'
    dma_timeframelen_o                       : out    std_logic_vector(31 downto 0)
  );
end dma_controller_wb_slave;

architecture syn of dma_controller_wb_slave is

signal dma_dcsr_int_read                        : std_logic_vector(31 downto 0);
signal dma_dcsr_int_write                       : std_logic_vector(31 downto 0);
signal dma_dcsr_lw                              : std_logic      ;
signal dma_dcsr_lw_delay                        : std_logic      ;
signal dma_dcsr_lw_read_in_progress             : std_logic      ;
signal dma_dcsr_lw_s0                           : std_logic      ;
signal dma_dcsr_lw_s1                           : std_logic      ;
signal dma_dcsr_lw_s2                           : std_logic      ;
signal dma_dcsr_rwsel                           : std_logic      ;
signal dma_ddmacsr_int_read                     : std_logic_vector(31 downto 0);
signal dma_ddmacsr_int_write                    : std_logic_vector(31 downto 0);
signal dma_ddmacsr_lw                           : std_logic      ;
signal dma_ddmacsr_lw_delay                     : std_logic      ;
signal dma_ddmacsr_lw_read_in_progress          : std_logic      ;
signal dma_ddmacsr_lw_s0                        : std_logic      ;
signal dma_ddmacsr_lw_s1                        : std_logic      ;
signal dma_ddmacsr_lw_s2                        : std_logic      ;
signal dma_ddmacsr_rwsel                        : std_logic      ;
signal dma_wdmatlpa_int_read                    : std_logic_vector(31 downto 0);
signal dma_wdmatlpa_int_write                   : std_logic_vector(31 downto 0);
signal dma_wdmatlpa_lw                          : std_logic      ;
signal dma_wdmatlpa_lw_delay                    : std_logic      ;
signal dma_wdmatlpa_lw_read_in_progress         : std_logic      ;
signal dma_wdmatlpa_lw_s0                       : std_logic      ;
signal dma_wdmatlpa_lw_s1                       : std_logic      ;
signal dma_wdmatlpa_lw_s2                       : std_logic      ;
signal dma_wdmatlpa_rwsel                       : std_logic      ;
signal dma_wdmatlps_int_read                    : std_logic_vector(31 downto 0);
signal dma_wdmatlps_int_write                   : std_logic_vector(31 downto 0);
signal dma_wdmatlps_lw                          : std_logic      ;
signal dma_wdmatlps_lw_delay                    : std_logic      ;
signal dma_wdmatlps_lw_read_in_progress         : std_logic      ;
signal dma_wdmatlps_lw_s0                       : std_logic      ;
signal dma_wdmatlps_lw_s1                       : std_logic      ;
signal dma_wdmatlps_lw_s2                       : std_logic      ;
signal dma_wdmatlps_rwsel                       : std_logic      ;
signal dma_wdmatlpc_int_read                    : std_logic_vector(31 downto 0);
signal dma_wdmatlpc_int_write                   : std_logic_vector(31 downto 0);
signal dma_wdmatlpc_lw                          : std_logic      ;
signal dma_wdmatlpc_lw_delay                    : std_logic      ;
signal dma_wdmatlpc_lw_read_in_progress         : std_logic      ;
signal dma_wdmatlpc_lw_s0                       : std_logic      ;
signal dma_wdmatlpc_lw_s1                       : std_logic      ;
signal dma_wdmatlpc_lw_s2                       : std_logic      ;
signal dma_wdmatlpc_rwsel                       : std_logic      ;
signal dma_wdmatlpp_int_read                    : std_logic_vector(31 downto 0);
signal dma_wdmatlpp_int_write                   : std_logic_vector(31 downto 0);
signal dma_wdmatlpp_lw                          : std_logic      ;
signal dma_wdmatlpp_lw_delay                    : std_logic      ;
signal dma_wdmatlpp_lw_read_in_progress         : std_logic      ;
signal dma_wdmatlpp_lw_s0                       : std_logic      ;
signal dma_wdmatlpp_lw_s1                       : std_logic      ;
signal dma_wdmatlpp_lw_s2                       : std_logic      ;
signal dma_wdmatlpp_rwsel                       : std_logic      ;
signal dma_rdmatlpp_int                         : std_logic_vector(31 downto 0);
signal dma_rdmatlpa_int                         : std_logic_vector(31 downto 0);
signal dma_rdmatlps_int                         : std_logic_vector(31 downto 0);
signal dma_rdmatlpc_int                         : std_logic_vector(31 downto 0);
signal dma_wdmaperf_int                         : std_logic_vector(31 downto 0);
signal dma_rdmaperf_int                         : std_logic_vector(31 downto 0);
signal dma_rdmastat_int                         : std_logic_vector(31 downto 0);
signal dma_nrdcomp_int                          : std_logic_vector(31 downto 0);
signal dma_rcompdsizw_int                       : std_logic_vector(31 downto 0);
signal dma_dlwstat_int                          : std_logic_vector(31 downto 0);
signal dma_dltrsstat_int                        : std_logic_vector(31 downto 0);
signal dma_dmisccont_int                        : std_logic_vector(31 downto 0);
signal dma_ccfaiirqclr_int                      : std_logic_vector(31 downto 0);
signal dma_na0_int                              : std_logic_vector(31 downto 0);
signal dma_na1_int                              : std_logic_vector(31 downto 0);
signal dma_na2_int                              : std_logic_vector(31 downto 0);
signal dma_na3_int                              : std_logic_vector(31 downto 0);
signal dma_na4_int                              : std_logic_vector(31 downto 0);
signal dma_na5_int                              : std_logic_vector(31 downto 0);
signal dma_na6_int                              : std_logic_vector(31 downto 0);
signal dma_na7_int                              : std_logic_vector(31 downto 0);
signal dma_na8_int                              : std_logic_vector(31 downto 0);
signal dma_na9_int                              : std_logic_vector(31 downto 0);
signal dma_na10_int                             : std_logic_vector(31 downto 0);
signal dma_na11_int                             : std_logic_vector(31 downto 0);
signal dma_na12_int                             : std_logic_vector(31 downto 0);
signal dma_ccfaicfgval_int                      : std_logic_vector(31 downto 0);
signal dma_ccfaicfgval_swb                      : std_logic      ;
signal dma_ccfaicfgval_swb_delay                : std_logic      ;
signal dma_ccfaicfgval_swb_s0                   : std_logic      ;
signal dma_ccfaicfgval_swb_s1                   : std_logic      ;
signal dma_ccfaicfgval_swb_s2                   : std_logic      ;
signal dma_wdmastatus_int                       : std_logic_vector(31 downto 0);
signal dma_wdmastatus_lwb                       : std_logic      ;
signal dma_wdmastatus_lwb_delay                 : std_logic      ;
signal dma_wdmastatus_lwb_in_progress           : std_logic      ;
signal dma_wdmastatus_lwb_s0                    : std_logic      ;
signal dma_wdmastatus_lwb_s1                    : std_logic      ;
signal dma_wdmastatus_lwb_s2                    : std_logic      ;
signal dma_linkstatus_int                       : std_logic_vector(31 downto 0);
signal dma_linkstatus_lwb                       : std_logic      ;
signal dma_linkstatus_lwb_delay                 : std_logic      ;
signal dma_linkstatus_lwb_in_progress           : std_logic      ;
signal dma_linkstatus_lwb_s0                    : std_logic      ;
signal dma_linkstatus_lwb_s1                    : std_logic      ;
signal dma_linkstatus_lwb_s2                    : std_logic      ;
signal dma_frameerrcnt_int                      : std_logic_vector(31 downto 0);
signal dma_frameerrcnt_lwb                      : std_logic      ;
signal dma_frameerrcnt_lwb_delay                : std_logic      ;
signal dma_frameerrcnt_lwb_in_progress          : std_logic      ;
signal dma_frameerrcnt_lwb_s0                   : std_logic      ;
signal dma_frameerrcnt_lwb_s1                   : std_logic      ;
signal dma_frameerrcnt_lwb_s2                   : std_logic      ;
signal dma_softerrcnt_int                       : std_logic_vector(31 downto 0);
signal dma_softerrcnt_lwb                       : std_logic      ;
signal dma_softerrcnt_lwb_delay                 : std_logic      ;
signal dma_softerrcnt_lwb_in_progress           : std_logic      ;
signal dma_softerrcnt_lwb_s0                    : std_logic      ;
signal dma_softerrcnt_lwb_s1                    : std_logic      ;
signal dma_softerrcnt_lwb_s2                    : std_logic      ;
signal dma_harderrcnt_int                       : std_logic_vector(31 downto 0);
signal dma_harderrcnt_lwb                       : std_logic      ;
signal dma_harderrcnt_lwb_delay                 : std_logic      ;
signal dma_harderrcnt_lwb_in_progress           : std_logic      ;
signal dma_harderrcnt_lwb_s0                    : std_logic      ;
signal dma_harderrcnt_lwb_s1                    : std_logic      ;
signal dma_harderrcnt_lwb_s2                    : std_logic      ;
signal dma_nodeid_int                           : std_logic_vector(31 downto 0);
signal dma_nodeid_swb                           : std_logic      ;
signal dma_nodeid_swb_delay                     : std_logic      ;
signal dma_nodeid_swb_s0                        : std_logic      ;
signal dma_nodeid_swb_s1                        : std_logic      ;
signal dma_nodeid_swb_s2                        : std_logic      ;
signal dma_timeframelen_int                     : std_logic_vector(31 downto 0);
signal dma_timeframelen_swb                     : std_logic      ;
signal dma_timeframelen_swb_delay               : std_logic      ;
signal dma_timeframelen_swb_s0                  : std_logic      ;
signal dma_timeframelen_swb_s1                  : std_logic      ;
signal dma_timeframelen_swb_s2                  : std_logic      ;
signal ack_sreg                                 : std_logic_vector(9 downto 0);
signal rddata_reg                               : std_logic_vector(31 downto 0);
signal wrdata_reg                               : std_logic_vector(31 downto 0);
signal bwsel_reg                                : std_logic_vector(3 downto 0);
signal rwaddr_reg                               : std_logic_vector(5 downto 0);
signal ack_in_progress                          : std_logic      ;
signal wr_int                                   : std_logic      ;
signal rd_int                                   : std_logic      ;
signal allones                                  : std_logic_vector(31 downto 0);
signal allzeros                                 : std_logic_vector(31 downto 0);

begin
-- Some internal signals assignments. For (foreseen) compatibility with other bus standards.
  wrdata_reg <= wb_dat_i;
  bwsel_reg <= wb_sel_i;
  rd_int <= wb_cyc_i and (wb_stb_i and (not wb_we_i));
  wr_int <= wb_cyc_i and (wb_stb_i and wb_we_i);
  allones <= (others => '1');
  allzeros <= (others => '0');
-- 
-- Main register bank access process.
  process (clk_sys_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      ack_sreg <= "0000000000";
      ack_in_progress <= '0';
      rddata_reg <= "00000000000000000000000000000000";
      dma_dcsr_lw <= '0';
      dma_dcsr_lw_delay <= '0';
      dma_dcsr_lw_read_in_progress <= '0';
      dma_dcsr_rwsel <= '0';
      dma_dcsr_int_write <= "00000000000000000000000000000000";
      dma_ddmacsr_lw <= '0';
      dma_ddmacsr_lw_delay <= '0';
      dma_ddmacsr_lw_read_in_progress <= '0';
      dma_ddmacsr_rwsel <= '0';
      dma_ddmacsr_int_write <= "00000000000000000000000000000000";
      dma_wdmatlpa_lw <= '0';
      dma_wdmatlpa_lw_delay <= '0';
      dma_wdmatlpa_lw_read_in_progress <= '0';
      dma_wdmatlpa_rwsel <= '0';
      dma_wdmatlpa_int_write <= "00000000000000000000000000000000";
      dma_wdmatlps_lw <= '0';
      dma_wdmatlps_lw_delay <= '0';
      dma_wdmatlps_lw_read_in_progress <= '0';
      dma_wdmatlps_rwsel <= '0';
      dma_wdmatlps_int_write <= "00000000000000000000000000000000";
      dma_wdmatlpc_lw <= '0';
      dma_wdmatlpc_lw_delay <= '0';
      dma_wdmatlpc_lw_read_in_progress <= '0';
      dma_wdmatlpc_rwsel <= '0';
      dma_wdmatlpc_int_write <= "00000000000000000000000000000000";
      dma_wdmatlpp_lw <= '0';
      dma_wdmatlpp_lw_delay <= '0';
      dma_wdmatlpp_lw_read_in_progress <= '0';
      dma_wdmatlpp_rwsel <= '0';
      dma_wdmatlpp_int_write <= "00000000000000000000000000000000";
      dma_rdmatlpp_int <= "00000000000000000000000000000000";
      dma_rdmatlpa_int <= "00000000000000000000000000000000";
      dma_rdmatlps_int <= "00000000000000000000000000000000";
      dma_rdmatlpc_int <= "00000000000000000000000000000000";
      dma_wdmaperf_int <= "00000000000000000000000000000000";
      dma_rdmaperf_int <= "00000000000000000000000000000000";
      dma_rdmastat_int <= "00000000000000000000000000000000";
      dma_nrdcomp_int <= "00000000000000000000000000000000";
      dma_rcompdsizw_int <= "00000000000000000000000000000000";
      dma_dlwstat_int <= "00000000000000000000000000000000";
      dma_dltrsstat_int <= "00000000000000000000000000000000";
      dma_dmisccont_int <= "00000000000000000000000000000000";
      dma_ccfaiirqclr_int <= "00000000000000000000000000000000";
      dma_na0_int <= "00000000000000000000000000000000";
      dma_na1_int <= "00000000000000000000000000000000";
      dma_na2_int <= "00000000000000000000000000000000";
      dma_na3_int <= "00000000000000000000000000000000";
      dma_na4_int <= "00000000000000000000000000000000";
      dma_na5_int <= "00000000000000000000000000000000";
      dma_na6_int <= "00000000000000000000000000000000";
      dma_na7_int <= "00000000000000000000000000000000";
      dma_na8_int <= "00000000000000000000000000000000";
      dma_na9_int <= "00000000000000000000000000000000";
      dma_na10_int <= "00000000000000000000000000000000";
      dma_na11_int <= "00000000000000000000000000000000";
      dma_na12_int <= "00000000000000000000000000000000";
      dma_ccfaicfgval_int <= "00000000000000000000000000000000";
      dma_ccfaicfgval_swb <= '0';
      dma_ccfaicfgval_swb_delay <= '0';
      dma_wdmastatus_lwb <= '0';
      dma_wdmastatus_lwb_delay <= '0';
      dma_wdmastatus_lwb_in_progress <= '0';
      dma_linkstatus_lwb <= '0';
      dma_linkstatus_lwb_delay <= '0';
      dma_linkstatus_lwb_in_progress <= '0';
      dma_frameerrcnt_lwb <= '0';
      dma_frameerrcnt_lwb_delay <= '0';
      dma_frameerrcnt_lwb_in_progress <= '0';
      dma_softerrcnt_lwb <= '0';
      dma_softerrcnt_lwb_delay <= '0';
      dma_softerrcnt_lwb_in_progress <= '0';
      dma_harderrcnt_lwb <= '0';
      dma_harderrcnt_lwb_delay <= '0';
      dma_harderrcnt_lwb_in_progress <= '0';
      dma_nodeid_int <= "00000000000000000000000000000000";
      dma_nodeid_swb <= '0';
      dma_nodeid_swb_delay <= '0';
      dma_timeframelen_int <= "00000000000000000000000000000000";
      dma_timeframelen_swb <= '0';
      dma_timeframelen_swb_delay <= '0';
    elsif rising_edge(clk_sys_i) then
-- advance the ACK generator shift register
      ack_sreg(8 downto 0) <= ack_sreg(9 downto 1);
      ack_sreg(9) <= '0';
      if (ack_in_progress = '1') then
        if (ack_sreg(0) = '1') then
          ack_in_progress <= '0';
        else
          dma_dcsr_lw <= dma_dcsr_lw_delay;
          dma_dcsr_lw_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_dcsr_lw_read_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_dcsr_int_read;
            dma_dcsr_lw_read_in_progress <= '0';
          end if;
          dma_ddmacsr_lw <= dma_ddmacsr_lw_delay;
          dma_ddmacsr_lw_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_ddmacsr_lw_read_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_ddmacsr_int_read;
            dma_ddmacsr_lw_read_in_progress <= '0';
          end if;
          dma_wdmatlpa_lw <= dma_wdmatlpa_lw_delay;
          dma_wdmatlpa_lw_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_wdmatlpa_lw_read_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_wdmatlpa_int_read;
            dma_wdmatlpa_lw_read_in_progress <= '0';
          end if;
          dma_wdmatlps_lw <= dma_wdmatlps_lw_delay;
          dma_wdmatlps_lw_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_wdmatlps_lw_read_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_wdmatlps_int_read;
            dma_wdmatlps_lw_read_in_progress <= '0';
          end if;
          dma_wdmatlpc_lw <= dma_wdmatlpc_lw_delay;
          dma_wdmatlpc_lw_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_wdmatlpc_lw_read_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_wdmatlpc_int_read;
            dma_wdmatlpc_lw_read_in_progress <= '0';
          end if;
          dma_wdmatlpp_lw <= dma_wdmatlpp_lw_delay;
          dma_wdmatlpp_lw_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_wdmatlpp_lw_read_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_wdmatlpp_int_read;
            dma_wdmatlpp_lw_read_in_progress <= '0';
          end if;
          dma_ccfaicfgval_swb <= dma_ccfaicfgval_swb_delay;
          dma_ccfaicfgval_swb_delay <= '0';
          dma_wdmastatus_lwb <= dma_wdmastatus_lwb_delay;
          dma_wdmastatus_lwb_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_wdmastatus_lwb_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_wdmastatus_int;
            dma_wdmastatus_lwb_in_progress <= '0';
          end if;
          dma_linkstatus_lwb <= dma_linkstatus_lwb_delay;
          dma_linkstatus_lwb_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_linkstatus_lwb_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_linkstatus_int;
            dma_linkstatus_lwb_in_progress <= '0';
          end if;
          dma_frameerrcnt_lwb <= dma_frameerrcnt_lwb_delay;
          dma_frameerrcnt_lwb_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_frameerrcnt_lwb_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_frameerrcnt_int;
            dma_frameerrcnt_lwb_in_progress <= '0';
          end if;
          dma_softerrcnt_lwb <= dma_softerrcnt_lwb_delay;
          dma_softerrcnt_lwb_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_softerrcnt_lwb_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_softerrcnt_int;
            dma_softerrcnt_lwb_in_progress <= '0';
          end if;
          dma_harderrcnt_lwb <= dma_harderrcnt_lwb_delay;
          dma_harderrcnt_lwb_delay <= '0';
          if ((ack_sreg(1) = '1') and (dma_harderrcnt_lwb_in_progress = '1')) then
            rddata_reg(31 downto 0) <= dma_harderrcnt_int;
            dma_harderrcnt_lwb_in_progress <= '0';
          end if;
          dma_nodeid_swb <= dma_nodeid_swb_delay;
          dma_nodeid_swb_delay <= '0';
          dma_timeframelen_swb <= dma_timeframelen_swb_delay;
          dma_timeframelen_swb_delay <= '0';
        end if;
      else
        if ((wb_cyc_i = '1') and (wb_stb_i = '1')) then
          case rwaddr_reg(5 downto 0) is
          when "000000" => 
            if (wb_we_i = '1') then
              dma_dcsr_int_write <= wrdata_reg(31 downto 0);
              dma_dcsr_lw <= '1';
              dma_dcsr_lw_delay <= '1';
              dma_dcsr_lw_read_in_progress <= '0';
              dma_dcsr_rwsel <= '1';
            end if;
            if (wb_we_i = '0') then
              dma_dcsr_lw <= '1';
              dma_dcsr_lw_delay <= '1';
              dma_dcsr_lw_read_in_progress <= '1';
              dma_dcsr_rwsel <= '0';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "000001" => 
            if (wb_we_i = '1') then
              dma_ddmacsr_int_write <= wrdata_reg(31 downto 0);
              dma_ddmacsr_lw <= '1';
              dma_ddmacsr_lw_delay <= '1';
              dma_ddmacsr_lw_read_in_progress <= '0';
              dma_ddmacsr_rwsel <= '1';
            end if;
            if (wb_we_i = '0') then
              dma_ddmacsr_lw <= '1';
              dma_ddmacsr_lw_delay <= '1';
              dma_ddmacsr_lw_read_in_progress <= '1';
              dma_ddmacsr_rwsel <= '0';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "000010" => 
            if (wb_we_i = '1') then
              dma_wdmatlpa_int_write <= wrdata_reg(31 downto 0);
              dma_wdmatlpa_lw <= '1';
              dma_wdmatlpa_lw_delay <= '1';
              dma_wdmatlpa_lw_read_in_progress <= '0';
              dma_wdmatlpa_rwsel <= '1';
            end if;
            if (wb_we_i = '0') then
              dma_wdmatlpa_lw <= '1';
              dma_wdmatlpa_lw_delay <= '1';
              dma_wdmatlpa_lw_read_in_progress <= '1';
              dma_wdmatlpa_rwsel <= '0';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "000011" => 
            if (wb_we_i = '1') then
              dma_wdmatlps_int_write <= wrdata_reg(31 downto 0);
              dma_wdmatlps_lw <= '1';
              dma_wdmatlps_lw_delay <= '1';
              dma_wdmatlps_lw_read_in_progress <= '0';
              dma_wdmatlps_rwsel <= '1';
            end if;
            if (wb_we_i = '0') then
              dma_wdmatlps_lw <= '1';
              dma_wdmatlps_lw_delay <= '1';
              dma_wdmatlps_lw_read_in_progress <= '1';
              dma_wdmatlps_rwsel <= '0';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "000100" => 
            if (wb_we_i = '1') then
              dma_wdmatlpc_int_write <= wrdata_reg(31 downto 0);
              dma_wdmatlpc_lw <= '1';
              dma_wdmatlpc_lw_delay <= '1';
              dma_wdmatlpc_lw_read_in_progress <= '0';
              dma_wdmatlpc_rwsel <= '1';
            end if;
            if (wb_we_i = '0') then
              dma_wdmatlpc_lw <= '1';
              dma_wdmatlpc_lw_delay <= '1';
              dma_wdmatlpc_lw_read_in_progress <= '1';
              dma_wdmatlpc_rwsel <= '0';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "000101" => 
            if (wb_we_i = '1') then
              dma_wdmatlpp_int_write <= wrdata_reg(31 downto 0);
              dma_wdmatlpp_lw <= '1';
              dma_wdmatlpp_lw_delay <= '1';
              dma_wdmatlpp_lw_read_in_progress <= '0';
              dma_wdmatlpp_rwsel <= '1';
            end if;
            if (wb_we_i = '0') then
              dma_wdmatlpp_lw <= '1';
              dma_wdmatlpp_lw_delay <= '1';
              dma_wdmatlpp_lw_read_in_progress <= '1';
              dma_wdmatlpp_rwsel <= '0';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "000110" => 
            if (wb_we_i = '1') then
              dma_rdmatlpp_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rdmatlpp_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "000111" => 
            if (wb_we_i = '1') then
              dma_rdmatlpa_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rdmatlpa_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001000" => 
            if (wb_we_i = '1') then
              dma_rdmatlps_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rdmatlps_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001001" => 
            if (wb_we_i = '1') then
              dma_rdmatlpc_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rdmatlpc_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001010" => 
            if (wb_we_i = '1') then
              dma_wdmaperf_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_wdmaperf_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001011" => 
            if (wb_we_i = '1') then
              dma_rdmaperf_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rdmaperf_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001100" => 
            if (wb_we_i = '1') then
              dma_rdmastat_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rdmastat_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001101" => 
            if (wb_we_i = '1') then
              dma_nrdcomp_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_nrdcomp_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001110" => 
            if (wb_we_i = '1') then
              dma_rcompdsizw_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_rcompdsizw_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "001111" => 
            if (wb_we_i = '1') then
              dma_dlwstat_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_dlwstat_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010000" => 
            if (wb_we_i = '1') then
              dma_dltrsstat_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_dltrsstat_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010001" => 
            if (wb_we_i = '1') then
              dma_dmisccont_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_dmisccont_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010010" => 
            if (wb_we_i = '1') then
              dma_ccfaiirqclr_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_ccfaiirqclr_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010011" => 
            if (wb_we_i = '1') then
              dma_na0_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na0_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010100" => 
            if (wb_we_i = '1') then
              dma_na1_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na1_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010101" => 
            if (wb_we_i = '1') then
              dma_na2_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na2_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010110" => 
            if (wb_we_i = '1') then
              dma_na3_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na3_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "010111" => 
            if (wb_we_i = '1') then
              dma_na4_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na4_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011000" => 
            if (wb_we_i = '1') then
              dma_na5_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na5_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011001" => 
            if (wb_we_i = '1') then
              dma_na6_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na6_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011010" => 
            if (wb_we_i = '1') then
              dma_na7_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na7_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011011" => 
            if (wb_we_i = '1') then
              dma_na8_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na8_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011100" => 
            if (wb_we_i = '1') then
              dma_na9_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na9_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011101" => 
            if (wb_we_i = '1') then
              dma_na10_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na10_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011110" => 
            if (wb_we_i = '1') then
              dma_na11_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na11_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "011111" => 
            if (wb_we_i = '1') then
              dma_na12_int <= wrdata_reg(31 downto 0);
            end if;
            rddata_reg(31 downto 0) <= dma_na12_int;
            ack_sreg(0) <= '1';
            ack_in_progress <= '1';
          when "100000" => 
            if (wb_we_i = '1') then
              dma_ccfaicfgval_int <= wrdata_reg(31 downto 0);
              dma_ccfaicfgval_swb <= '1';
              dma_ccfaicfgval_swb_delay <= '1';
            end if;
            rddata_reg(31 downto 0) <= dma_ccfaicfgval_int;
            ack_sreg(3) <= '1';
            ack_in_progress <= '1';
          when "100001" => 
            if (wb_we_i = '1') then
            end if;
            if (wb_we_i = '0') then
              dma_wdmastatus_lwb <= '1';
              dma_wdmastatus_lwb_delay <= '1';
              dma_wdmastatus_lwb_in_progress <= '1';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "100010" => 
            if (wb_we_i = '1') then
            end if;
            if (wb_we_i = '0') then
              dma_linkstatus_lwb <= '1';
              dma_linkstatus_lwb_delay <= '1';
              dma_linkstatus_lwb_in_progress <= '1';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "100011" => 
            if (wb_we_i = '1') then
            end if;
            if (wb_we_i = '0') then
              dma_frameerrcnt_lwb <= '1';
              dma_frameerrcnt_lwb_delay <= '1';
              dma_frameerrcnt_lwb_in_progress <= '1';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "100100" => 
            if (wb_we_i = '1') then
            end if;
            if (wb_we_i = '0') then
              dma_softerrcnt_lwb <= '1';
              dma_softerrcnt_lwb_delay <= '1';
              dma_softerrcnt_lwb_in_progress <= '1';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "100101" => 
            if (wb_we_i = '1') then
            end if;
            if (wb_we_i = '0') then
              dma_harderrcnt_lwb <= '1';
              dma_harderrcnt_lwb_delay <= '1';
              dma_harderrcnt_lwb_in_progress <= '1';
            end if;
            ack_sreg(5) <= '1';
            ack_in_progress <= '1';
          when "100110" => 
            if (wb_we_i = '1') then
              dma_nodeid_int <= wrdata_reg(31 downto 0);
              dma_nodeid_swb <= '1';
              dma_nodeid_swb_delay <= '1';
            end if;
            rddata_reg(31 downto 0) <= dma_nodeid_int;
            ack_sreg(3) <= '1';
            ack_in_progress <= '1';
          when "100111" => 
            if (wb_we_i = '1') then
              dma_timeframelen_int <= wrdata_reg(31 downto 0);
              dma_timeframelen_swb <= '1';
              dma_timeframelen_swb_delay <= '1';
            end if;
            rddata_reg(31 downto 0) <= dma_timeframelen_int;
            ack_sreg(3) <= '1';
            ack_in_progress <= '1';
          when others =>
-- prevent the slave from hanging the bus on invalid address
            ack_in_progress <= '1';
            ack_sreg(0) <= '1';
          end case;
        end if;
      end if;
    end if;
  end process;
  
  
-- Drive the data output bus
  wb_dat_o <= rddata_reg;
-- Device Control and Status Register
-- asynchronous std_logic_vector register : Device Control and Status Register (type RW/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_dcsr_lw_s0 <= '0';
      dma_dcsr_lw_s1 <= '0';
      dma_dcsr_lw_s2 <= '0';
      dma_dcsr_o <= "00000000000000000000000000000000";
      dma_dcsr_load_o <= '0';
      dma_dcsr_int_read <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_dcsr_lw_s0 <= dma_dcsr_lw;
      dma_dcsr_lw_s1 <= dma_dcsr_lw_s0;
      dma_dcsr_lw_s2 <= dma_dcsr_lw_s1;
      if ((dma_dcsr_lw_s2 = '0') and (dma_dcsr_lw_s1 = '1')) then
        if (dma_dcsr_rwsel = '1') then
          dma_dcsr_o <= dma_dcsr_int_write;
          dma_dcsr_load_o <= '1';
        else
          dma_dcsr_load_o <= '0';
          dma_dcsr_int_read <= dma_dcsr_i;
        end if;
      else
        dma_dcsr_load_o <= '0';
      end if;
    end if;
  end process;
  
  
-- Device DMA Control Status Register
-- asynchronous std_logic_vector register : Device DMA Control Status Register (type RW/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_ddmacsr_lw_s0 <= '0';
      dma_ddmacsr_lw_s1 <= '0';
      dma_ddmacsr_lw_s2 <= '0';
      dma_ddmacsr_o <= "00000000000000000000000000000000";
      dma_ddmacsr_load_o <= '0';
      dma_ddmacsr_int_read <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_ddmacsr_lw_s0 <= dma_ddmacsr_lw;
      dma_ddmacsr_lw_s1 <= dma_ddmacsr_lw_s0;
      dma_ddmacsr_lw_s2 <= dma_ddmacsr_lw_s1;
      if ((dma_ddmacsr_lw_s2 = '0') and (dma_ddmacsr_lw_s1 = '1')) then
        if (dma_ddmacsr_rwsel = '1') then
          dma_ddmacsr_o <= dma_ddmacsr_int_write;
          dma_ddmacsr_load_o <= '1';
        else
          dma_ddmacsr_load_o <= '0';
          dma_ddmacsr_int_read <= dma_ddmacsr_i;
        end if;
      else
        dma_ddmacsr_load_o <= '0';
      end if;
    end if;
  end process;
  
  
-- Write DMA Host Lower Address
-- asynchronous std_logic_vector register : Write DMA Host Lower Address (type RW/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_wdmatlpa_lw_s0 <= '0';
      dma_wdmatlpa_lw_s1 <= '0';
      dma_wdmatlpa_lw_s2 <= '0';
      dma_wdmatlpa_o <= "00000000000000000000000000000000";
      dma_wdmatlpa_load_o <= '0';
      dma_wdmatlpa_int_read <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_wdmatlpa_lw_s0 <= dma_wdmatlpa_lw;
      dma_wdmatlpa_lw_s1 <= dma_wdmatlpa_lw_s0;
      dma_wdmatlpa_lw_s2 <= dma_wdmatlpa_lw_s1;
      if ((dma_wdmatlpa_lw_s2 = '0') and (dma_wdmatlpa_lw_s1 = '1')) then
        if (dma_wdmatlpa_rwsel = '1') then
          dma_wdmatlpa_o <= dma_wdmatlpa_int_write;
          dma_wdmatlpa_load_o <= '1';
        else
          dma_wdmatlpa_load_o <= '0';
          dma_wdmatlpa_int_read <= dma_wdmatlpa_i;
        end if;
      else
        dma_wdmatlpa_load_o <= '0';
      end if;
    end if;
  end process;
  
  
-- Write DMA TLP Size
-- asynchronous std_logic_vector register : Write DMA TLP Size (type RW/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_wdmatlps_lw_s0 <= '0';
      dma_wdmatlps_lw_s1 <= '0';
      dma_wdmatlps_lw_s2 <= '0';
      dma_wdmatlps_o <= "00000000000000000000000000000000";
      dma_wdmatlps_load_o <= '0';
      dma_wdmatlps_int_read <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_wdmatlps_lw_s0 <= dma_wdmatlps_lw;
      dma_wdmatlps_lw_s1 <= dma_wdmatlps_lw_s0;
      dma_wdmatlps_lw_s2 <= dma_wdmatlps_lw_s1;
      if ((dma_wdmatlps_lw_s2 = '0') and (dma_wdmatlps_lw_s1 = '1')) then
        if (dma_wdmatlps_rwsel = '1') then
          dma_wdmatlps_o <= dma_wdmatlps_int_write;
          dma_wdmatlps_load_o <= '1';
        else
          dma_wdmatlps_load_o <= '0';
          dma_wdmatlps_int_read <= dma_wdmatlps_i;
        end if;
      else
        dma_wdmatlps_load_o <= '0';
      end if;
    end if;
  end process;
  
  
-- write DMA TLP count
-- asynchronous std_logic_vector register : write DMA TLP count (type RW/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_wdmatlpc_lw_s0 <= '0';
      dma_wdmatlpc_lw_s1 <= '0';
      dma_wdmatlpc_lw_s2 <= '0';
      dma_wdmatlpc_o <= "00000000000000000000000000000000";
      dma_wdmatlpc_load_o <= '0';
      dma_wdmatlpc_int_read <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_wdmatlpc_lw_s0 <= dma_wdmatlpc_lw;
      dma_wdmatlpc_lw_s1 <= dma_wdmatlpc_lw_s0;
      dma_wdmatlpc_lw_s2 <= dma_wdmatlpc_lw_s1;
      if ((dma_wdmatlpc_lw_s2 = '0') and (dma_wdmatlpc_lw_s1 = '1')) then
        if (dma_wdmatlpc_rwsel = '1') then
          dma_wdmatlpc_o <= dma_wdmatlpc_int_write;
          dma_wdmatlpc_load_o <= '1';
        else
          dma_wdmatlpc_load_o <= '0';
          dma_wdmatlpc_int_read <= dma_wdmatlpc_i;
        end if;
      else
        dma_wdmatlpc_load_o <= '0';
      end if;
    end if;
  end process;
  
  
-- write DMA pattern
-- asynchronous std_logic_vector register : write DMA pattern (type RW/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_wdmatlpp_lw_s0 <= '0';
      dma_wdmatlpp_lw_s1 <= '0';
      dma_wdmatlpp_lw_s2 <= '0';
      dma_wdmatlpp_o <= "00000000000000000000000000000000";
      dma_wdmatlpp_load_o <= '0';
      dma_wdmatlpp_int_read <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_wdmatlpp_lw_s0 <= dma_wdmatlpp_lw;
      dma_wdmatlpp_lw_s1 <= dma_wdmatlpp_lw_s0;
      dma_wdmatlpp_lw_s2 <= dma_wdmatlpp_lw_s1;
      if ((dma_wdmatlpp_lw_s2 = '0') and (dma_wdmatlpp_lw_s1 = '1')) then
        if (dma_wdmatlpp_rwsel = '1') then
          dma_wdmatlpp_o <= dma_wdmatlpp_int_write;
          dma_wdmatlpp_load_o <= '1';
        else
          dma_wdmatlpp_load_o <= '0';
          dma_wdmatlpp_int_read <= dma_wdmatlpp_i;
        end if;
      else
        dma_wdmatlpp_load_o <= '0';
      end if;
    end if;
  end process;
  
  
-- read DMA expected pattern
  dma_rdmatlpp_o <= dma_rdmatlpp_int;
-- read DMA TLP address
  dma_rdmatlpa_o <= dma_rdmatlpa_int;
-- read DMA TLP size
  dma_rdmatlps_o <= dma_rdmatlps_int;
-- read DMA TLP count
  dma_rdmatlpc_o <= dma_rdmatlpc_int;
-- write DMA performace
  dma_wdmaperf_o <= dma_wdmaperf_int;
-- read DMA performace
  dma_rdmaperf_o <= dma_rdmaperf_int;
-- read DMA status
  dma_rdmastat_o <= dma_rdmastat_int;
-- Number of Read Completion
  dma_nrdcomp_o <= dma_nrdcomp_int;
-- Read Completion Data Size
  dma_rcompdsizw_o <= dma_rcompdsizw_int;
-- Device Link Width Status
  dma_dlwstat_o <= dma_dlwstat_int;
-- Device Link Transaction Size Status
  dma_dltrsstat_o <= dma_dltrsstat_int;
-- Device Miscellaneous Control
  dma_dmisccont_o <= dma_dmisccont_int;
-- CC FAI interrupt clear register
  dma_ccfaiirqclr_o <= dma_ccfaiirqclr_int;
-- Not Used 0
  dma_na0_o <= dma_na0_int;
-- Not Used 1
  dma_na1_o <= dma_na1_int;
-- Not Used 2
  dma_na2_o <= dma_na2_int;
-- Not Used 3
  dma_na3_o <= dma_na3_int;
-- Not Used 4
  dma_na4_o <= dma_na4_int;
-- Not Used 5
  dma_na5_o <= dma_na5_int;
-- Not Used 6
  dma_na6_o <= dma_na6_int;
-- Not Used 7
  dma_na7_o <= dma_na7_int;
-- Not Used 8
  dma_na8_o <= dma_na8_int;
-- Not Used 9
  dma_na9_o <= dma_na9_int;
-- Not Used 10
  dma_na10_o <= dma_na10_int;
-- Not Used 11
  dma_na11_o <= dma_na11_int;
-- Not Used 12
  dma_na12_o <= dma_na12_int;
-- Communication Controller FAI Value
-- asynchronous std_logic_vector register : Communication Controller FAI Value (type RW/RO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_ccfaicfgval_swb_s0 <= '0';
      dma_ccfaicfgval_swb_s1 <= '0';
      dma_ccfaicfgval_swb_s2 <= '0';
      dma_ccfaicfgval_o <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_ccfaicfgval_swb_s0 <= dma_ccfaicfgval_swb;
      dma_ccfaicfgval_swb_s1 <= dma_ccfaicfgval_swb_s0;
      dma_ccfaicfgval_swb_s2 <= dma_ccfaicfgval_swb_s1;
      if ((dma_ccfaicfgval_swb_s2 = '0') and (dma_ccfaicfgval_swb_s1 = '1')) then
        dma_ccfaicfgval_o <= dma_ccfaicfgval_int;
      end if;
    end if;
  end process;
  
  
-- Write DMA Status Register
-- asynchronous std_logic_vector register : Write DMA Status Register (type RO/WO, clk_i <-> clk_sys_i)
  process (clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_wdmastatus_lwb_s0 <= '0';
      dma_wdmastatus_lwb_s1 <= '0';
      dma_wdmastatus_lwb_s2 <= '0';
      dma_wdmastatus_int <= "00000000000000000000000000000000";
    elsif rising_edge(clk_i) then
      dma_wdmastatus_lwb_s0 <= dma_wdmastatus_lwb;
      dma_wdmastatus_lwb_s1 <= dma_wdmastatus_lwb_s0;
      dma_wdmastatus_lwb_s2 <= dma_wdmastatus_lwb_s1;
      if ((dma_wdmastatus_lwb_s1 = '1') and (dma_wdmastatus_lwb_s2 = '0')) then
        dma_wdmastatus_int <= dma_wdmastatus_i;
      end if;
    end if;
  end process;
  
  
-- Communication Controller Link Status
-- asynchronous std_logic_vector register : Communication Controller Link Status (type RO/WO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_linkstatus_lwb_s0 <= '0';
      dma_linkstatus_lwb_s1 <= '0';
      dma_linkstatus_lwb_s2 <= '0';
      dma_linkstatus_int <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_linkstatus_lwb_s0 <= dma_linkstatus_lwb;
      dma_linkstatus_lwb_s1 <= dma_linkstatus_lwb_s0;
      dma_linkstatus_lwb_s2 <= dma_linkstatus_lwb_s1;
      if ((dma_linkstatus_lwb_s1 = '1') and (dma_linkstatus_lwb_s2 = '0')) then
        dma_linkstatus_int <= dma_linkstatus_i;
      end if;
    end if;
  end process;
  
  
-- Communication Controller Frame Error Status
-- asynchronous std_logic_vector register : Communication Controller Frame Error Status (type RO/WO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_frameerrcnt_lwb_s0 <= '0';
      dma_frameerrcnt_lwb_s1 <= '0';
      dma_frameerrcnt_lwb_s2 <= '0';
      dma_frameerrcnt_int <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_frameerrcnt_lwb_s0 <= dma_frameerrcnt_lwb;
      dma_frameerrcnt_lwb_s1 <= dma_frameerrcnt_lwb_s0;
      dma_frameerrcnt_lwb_s2 <= dma_frameerrcnt_lwb_s1;
      if ((dma_frameerrcnt_lwb_s1 = '1') and (dma_frameerrcnt_lwb_s2 = '0')) then
        dma_frameerrcnt_int <= dma_frameerrcnt_i;
      end if;
    end if;
  end process;
  
  
-- Communication Controller Soft Error Status
-- asynchronous std_logic_vector register : Communication Controller Soft Error Status (type RO/WO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_softerrcnt_lwb_s0 <= '0';
      dma_softerrcnt_lwb_s1 <= '0';
      dma_softerrcnt_lwb_s2 <= '0';
      dma_softerrcnt_int <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_softerrcnt_lwb_s0 <= dma_softerrcnt_lwb;
      dma_softerrcnt_lwb_s1 <= dma_softerrcnt_lwb_s0;
      dma_softerrcnt_lwb_s2 <= dma_softerrcnt_lwb_s1;
      if ((dma_softerrcnt_lwb_s1 = '1') and (dma_softerrcnt_lwb_s2 = '0')) then
        dma_softerrcnt_int <= dma_softerrcnt_i;
      end if;
    end if;
  end process;
  
  
-- Communication Controller Hard Error Status
-- asynchronous std_logic_vector register : Communication Controller Hard Error Status (type RO/WO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_harderrcnt_lwb_s0 <= '0';
      dma_harderrcnt_lwb_s1 <= '0';
      dma_harderrcnt_lwb_s2 <= '0';
      dma_harderrcnt_int <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_harderrcnt_lwb_s0 <= dma_harderrcnt_lwb;
      dma_harderrcnt_lwb_s1 <= dma_harderrcnt_lwb_s0;
      dma_harderrcnt_lwb_s2 <= dma_harderrcnt_lwb_s1;
      if ((dma_harderrcnt_lwb_s1 = '1') and (dma_harderrcnt_lwb_s2 = '0')) then
        dma_harderrcnt_int <= dma_harderrcnt_i;
      end if;
    end if;
  end process;
  
  
-- Communication Controller NodeID
-- asynchronous std_logic_vector register : Communication Controller NodeID (type RW/RO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_nodeid_swb_s0 <= '0';
      dma_nodeid_swb_s1 <= '0';
      dma_nodeid_swb_s2 <= '0';
      dma_nodeid_o <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_nodeid_swb_s0 <= dma_nodeid_swb;
      dma_nodeid_swb_s1 <= dma_nodeid_swb_s0;
      dma_nodeid_swb_s2 <= dma_nodeid_swb_s1;
      if ((dma_nodeid_swb_s2 = '0') and (dma_nodeid_swb_s1 = '1')) then
        dma_nodeid_o <= dma_nodeid_int;
      end if;
    end if;
  end process;
  
  
-- Communication Controller Timeframe Length
-- asynchronous std_logic_vector register : Communication Controller Timeframe Length (type RW/RO, fai_clk_i <-> clk_sys_i)
  process (fai_clk_i, rst_n_i)
  begin
    if (rst_n_i = '0') then 
      dma_timeframelen_swb_s0 <= '0';
      dma_timeframelen_swb_s1 <= '0';
      dma_timeframelen_swb_s2 <= '0';
      dma_timeframelen_o <= "00000000000000000000000000000000";
    elsif rising_edge(fai_clk_i) then
      dma_timeframelen_swb_s0 <= dma_timeframelen_swb;
      dma_timeframelen_swb_s1 <= dma_timeframelen_swb_s0;
      dma_timeframelen_swb_s2 <= dma_timeframelen_swb_s1;
      if ((dma_timeframelen_swb_s2 = '0') and (dma_timeframelen_swb_s1 = '1')) then
        dma_timeframelen_o <= dma_timeframelen_int;
      end if;
    end if;
  end process;
  
  
  rwaddr_reg <= wb_adr_i;
  wb_stall_o <= (not ack_sreg(0)) and (wb_stb_i and wb_cyc_i);
-- ACK signal generation. Just pass the LSB of ACK counter.
  wb_ack_o <= ack_sreg(0);
end syn;
